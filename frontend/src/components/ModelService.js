import React,{useEffect,useState,useRef}from"react";function ModelService(e){const[t,r]=useState(null);const[o,n]=useState(null);const[s,c]=useState(null);const[a,i]=useState(null);const[l,d]=useState(false);const[y,u]=useState(null);const[f,g]=useState(null);const[w,h]=useState(false);const[p,m]=useState(false);const[S,b]=useState(false);const[E,v]=useState(false);const[A,P]=useState(false);const[M,k]=useState(false);const[C,K]=useState(false);const[H,j]=useState(null);const[D,B]=useState(false);const[L,I]=useState(false);const N=useRef(1);const R=useRef(false);const U=process.env.REACT_APP_MODELSURL;const V=process.env.REACT_APP_VERIFICATIONURL;const T=process.env.REACT_APP_VERSIONSURL;const[x,O]=useState(false);console.log(U);const F=async()=>{v(true);try{const e=await window.crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},true,["deriveKey","deriveBits"]);const t=await window.crypto.subtle.exportKey("pkcs8",e.privateKey);await Q("privateKey",t);const o=await window.crypto.subtle.exportKey("raw",e.publicKey);const n=btoa(String.fromCharCode(...new Uint8Array(o)));console.log(n);r(n);h(true);console.log("ECDH key pair generated and private key stored securely!")}catch(e){console.error("Error generating ECDH key pair:",e)}finally{v(false)}};const _=async()=>{P(true);try{if(!t){throw new Error("Please generate key pair first!")}await Y();d(true)}catch(e){console.error("Error loading model:",e)}finally{P(false)}};const z=async()=>{try{const t=await ye(y.map((e=>e.decryptedModel)));if(await ae(t,f)){console.log("All models verified successfully!");B(true);e.setIsVerified(true);e.setIsVerifying(false);e.setReVerify(false);B(false)}else{N.current=0;console.log("Model verification failed, aborting decryption.");e.setIsVerifying(false);e.setIsVerified(false);e.setReVerify(false);d(false)}}catch(t){console.log("Error Verifying models:",t);N.current=0;e.setIsVerifying(false)}};const J=async(e,t)=>{try{const r=Uint8Array.from(atob(t),(e=>e.charCodeAt(0)));const o=await window.crypto.subtle.importKey("raw",r,{name:"ECDH",namedCurve:"P-256"},false,[]);const n=await window.crypto.subtle.deriveBits({name:"ECDH",public:o},e,256);const s=n;const c=await window.crypto.subtle.digest("SHA-256",s);const a=await window.crypto.subtle.importKey("raw",c,{name:"AES-CBC"},true,["encrypt","decrypt"]);console.log("AES key generated successfully!");const i=await window.crypto.subtle.exportKey("raw",a);const l=Array.from(new Uint8Array(i)).map((e=>e.toString(16).padStart(2,"0"))).join("");console.log("AES Key in Hex:",l);return a}catch(e){console.error("Error generating AES key:",e);throw e}};const $=async()=>{k(true);try{console.log("Decrypting models...");const e=await W("privateKey");if(!e){console.error("Frontend private key not found!");return}console.log(e);const t=await J(e,H);await oe(o,t,a,f);const r=[];for(const e of o){const{modelName:o,encryptedModel:n,version:s}=e;const c=await ie(t,n,a);r.push({modelName:o,decryptedModel:c,version:s})}u(r);m(true)}catch(e){console.error("Error decrypting models:",e)}finally{k(false)}};const G=()=>{const e=localStorage.getItem("decryptedModels");return e?JSON.parse(e):null};const Y=async()=>{try{const e=await fetch(U,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({publicKey:t})});if(!e.ok){throw new Error(`HTTP error! status: ${e.status}`)}const r=await e.json();console.log("Received encrypted data lengths:",{models:r.encryptedModels?.length,keyLength:r.backendPublicKey?.length,ivLength:r.iv?.length});if(r.encryptedModels&&r.backendPublicKey&&r.iv&&r.signedCombinedHash){const e=r.backendPublicKey;ee(r.signedCombinedHash);q(e);await new Promise((e=>setTimeout(e,200)));n(r.encryptedModels);i(r.iv);g(r.signedCombinedHash)}else{throw new Error("Failed to fetch encrypted model: "+(r.message||"Unknown error"))}}catch(e){console.error("Error fetching encrypted model:",e);throw e}};const q=e=>{j(e)};const Q=async(e,t)=>new Promise(((r,o)=>{const n=indexedDB.open("SecureKeysDB",1);n.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains("keys")){t.createObjectStore("keys")}};n.onsuccess=n=>{const s=n.target.result;const c=s.transaction("keys","readwrite");const a=c.objectStore("keys");const i=a.put(t,e);i.onsuccess=()=>r();i.onerror=()=>o(i.error)};n.onerror=()=>o(n.error)}));const W=async e=>new Promise(((t,r)=>{const o=indexedDB.open("SecureKeysDB",1);o.onsuccess=o=>{const n=o.target.result;const s=n.transaction("keys","readonly");const c=s.objectStore("keys");const a=c.get(e);a.onsuccess=async()=>{const o=a.result;if(e==="privateKey"){try{const e=await window.crypto.subtle.importKey("pkcs8",o,{name:"ECDH",namedCurve:"P-256"},true,["deriveKey","deriveBits"]);t(e)}catch(e){r(`Failed to import private key: ${e}`)}}else{t(o)}};a.onerror=()=>r(a.error)};o.onerror=()=>r(o.error)}));const X=async(e,t)=>{try{console.log("Starting AES key decryption...");const r=fe(t);console.log("Encrypted AES key details:",{byteLength:r.byteLength,firstFewBytes:Array.from(new Uint8Array(r.slice(0,4)))});console.log(e);const o=await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:{name:"SHA-256"}},e,r);console.log("Decrypted AES key details:",{byteLength:o.byteLength,expectedLength:32});const n=await window.crypto.subtle.importKey("raw",o,{name:"AES-CBC",length:256},false,["decrypt"]);return n}catch(e){console.error("Detailed error in decryptAesKey:",{message:e.message,name:e.name,stack:e.stack,inputKeyLength:t?.length});throw e}};async function Z(e){try{if(!e){throw new Error("PEM key is undefined or null")}const t=e.replace("-----BEGIN PUBLIC KEY-----","").replace("-----END PUBLIC KEY-----","").replace(/[\r\n]+/g,"").trim();console.log("Cleaned PEM contents length:",t.length);const r=window.atob(t);const o=new Uint8Array(r.length);for(let e=0;e<r.length;e++){o[e]=r.charCodeAt(e)}return await window.crypto.subtle.importKey("spki",o.buffer,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},true,["verify"])}catch(t){console.error("Error importing public key:",t);console.error("PEM key received:",e);throw t}}const ee=async e=>{try{const t=await re();return new Promise(((r,o)=>{const n=t.transaction(["signedHash"],"readwrite");const s=n.objectStore("signedHash");const c=s.put({id:"currentHash",hash:e});c.onsuccess=()=>{console.log("Signed Hash stored successfully");r()};c.onerror=()=>{console.error("Error storing signed hash:",c.error);o(c.error)};n.oncomplete=()=>{t.close()}}))}catch(e){console.error("Error in storeSignedHash:",e);throw e}};const te=async()=>{try{const e=await re();return new Promise(((t,r)=>{const o=e.transaction(["signedHash"],"readonly");const n=o.objectStore("signedHash");const s=n.get("currentHash");s.onsuccess=()=>{const e=s.result;t(e?e.hash:null)};s.onerror=()=>{r(s.error)};o.oncomplete=()=>{e.close()}}))}catch(e){console.error("Error fetching signed hash:",e);return null}};const re=()=>new Promise(((e,t)=>{const r=indexedDB.open("EncryptedModelsDB",1);r.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains("encryptedModels")){t.createObjectStore("encryptedModels",{keyPath:"id"})}if(!t.objectStoreNames.contains("signedHash")){t.createObjectStore("signedHash",{keyPath:"id"})}if(!t.objectStoreNames.contains("aesKey")){t.createObjectStore("aesKey",{keyPath:"id"})}};r.onsuccess=()=>e(r.result);r.onerror=()=>t(r.error)}));const oe=async(e,t,r,o)=>{try{const n=await re();const s=n.transaction(["encryptedModels","aesKey","signedHash"],"readwrite");s.objectStore("encryptedModels").put({id:"currentModels",models:e,iv:r});s.objectStore("aesKey").put({id:"currentKey",key:t});s.objectStore("signedHash").put({id:"currentHash",hash:o});return new Promise(((e,t)=>{s.oncomplete=()=>{console.log("Stored all encrypted data successfully");e()};s.onerror=()=>t(s.error)}))}catch(e){console.error("Error storing encrypted data:",e);throw e}};const ne=async()=>{try{const e=await re();const[t,r,o]=await Promise.all([new Promise(((t,r)=>{const o=e.transaction("encryptedModels").objectStore("encryptedModels").get("currentModels");o.onsuccess=()=>t(o.result);o.onerror=()=>r(o.error)})),new Promise(((t,r)=>{const o=e.transaction("aesKey").objectStore("aesKey").get("currentKey");o.onsuccess=()=>t(o.result);o.onerror=()=>r(o.error)})),new Promise(((t,r)=>{const o=e.transaction("signedHash").objectStore("signedHash").get("currentHash");o.onsuccess=()=>t(o.result);o.onerror=()=>r(o.error)}))]);if(!t||!r||!o){console.log("No stored data found");return[null,null,null]}return[t,r.key,o.hash]}catch(e){console.error("Error retrieving stored data:",e);return[null,null,null]}};const se=async e=>{const t=await re();return new Promise(((r,o)=>{const n=t.transaction("decryptedModels","readwrite");const s=n.objectStore("decryptedModels");s.put({id:"allModels",data:e});n.oncomplete=()=>{console.log("Decrypted models stored successfully.");r()};n.onerror=e=>{console.error("Error storing decrypted models:",e.target.error);o(e.target.error)}}))};const ce=async()=>{const e=await re();return new Promise(((t,r)=>{const o=e.transaction("decryptedModels","readonly");const n=o.objectStore("decryptedModels");const s=n.get("allModels");s.onsuccess=e=>{if(s.result){console.log("Decrypted models retrieved successfully.");t(s.result.data)}else{console.warn("No decrypted models found in IndexedDB.");t(null)}};s.onerror=e=>{console.error("Error retrieving decrypted models:",e.target.error);r(e.target.error)}}))};async function ae(e,t){try{const r=y.reduce(((e,t)=>{e[t.modelName]=t.version;return e}),{});const o=await fetch(V,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({combinedHash:e,digitalSignature:t,livenessStatus:true,versions:r})});const n=await o.json();if(o.status===200){console.log("Model verified and authenticated:",n.message);return true}else if(o.status===400){console.error("Combined hash and digital signature are required:",n.message)}else if(o.status===401){console.error("Invalid digital signature. Verification failed:",n.message)}else if(o.status===500){console.error("Error verifying model:",n.message)}else{console.error("Unexpected response:",n.message)}return false}catch(e){console.error("Error verifying hash:",e);return false}}const ie=async(e,t,r)=>{try{console.log("Decrypting model with AES...");const o=fe(t);const n=new Uint8Array(fe(r));console.log("Encrypted model size:",o.byteLength);console.log("IV size:",n.byteLength);const s={name:"AES-CBC",iv:n};const c=await window.crypto.subtle.decrypt(s,e,o);console.log("Model decrypted successfully! Size:",c.byteLength);return c}catch(e){console.error("Error decrypting model:",e);throw new Error("Model decryption failed.")}};async function le(e){try{const t=await crypto.subtle.digest("SHA-256",e);return ue(t)}catch(e){console.error("Error generating hash:",e);throw new Error("Failed to generate model hash.")}}const de=e=>{let t="";const r=new Uint8Array(e);for(let e=0;e<r.byteLength;e++){t+=String.fromCharCode(r[e])}return window.btoa(t)};async function ye(e){try{console.log(e);const t=new Uint8Array(e.reduce(((e,t)=>e+t.byteLength),0));let r=0;for(const o of e){t.set(new Uint8Array(o),r);r+=o.byteLength}const o=await crypto.subtle.digest("SHA-256",t.buffer);return ue(o)}catch(e){console.error("Error generating combined hash:",e);throw new Error("Failed to generate combined model hash.")}}function ue(e){const t=new Uint8Array(e);return Array.from(t).map((e=>e.toString(16).padStart(2,"0"))).join("")}const fe=e=>{try{const t=window.atob(e);const r=new Uint8Array(t.length);for(let e=0;e<r.length;e++){r[e]=t.charCodeAt(e)}return r.buffer}catch(e){console.error("Error in base64ToArrayBuffer:",e);throw new Error("Invalid base64 string")}};const ge=e=>{if(e<1024)return e+" bytes";else if(e<1024*1024)return(e/1024).toFixed(2)+" KB";else return(e/(1024*1024)).toFixed(2)+" MB"};const we=async()=>{try{const[e,t,r]=await ne();if(e&&t&&r){console.log("Using cached encrypted models");const o=[];for(const r of e.models){const n=await ie(t,r.encryptedModel,e.iv);o.push({modelName:r.modelName,decryptedModel:n,version:r.version})}u(o);g(r);return 1}if(!w){return 0}else if(w&&!l){await _();return 0}else if(l&&!p){await $();return 0}return 0}catch(e){console.error("Error in initializeModels:",e);return 0}};useEffect((()=>{const t=async()=>{try{if(!R.current){R.current=true;N.current=await we();if(N.current===0){b((e=>!e))}return}if(N.current===1&&!x){await he()}else if(N.current===0){if(!w){await F()}else if(w&&!l){await _()}else if(l&&!p){await $()}}if(e.reVerify&&!D){await z()}else if(p||x){e.setDecryptedModels(y);e.setModelReady(true)}else if(D){e.setIsVerified(true);e.setReVerify(false);e.setIsVerifying(false);B(false)}}catch(e){console.error("Error in initialization:",e);N.current=0;b((e=>!e))}};t()}),[w,S,l,p,D,e.reVerify,y,x]);const he=async()=>{try{const e=await fetch(T,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok){throw new Error(`HTTP error! status: ${e.status}`)}const{versions:t}=await e.json();const r=y.every((e=>t[e.modelName]===e.version));if(!r){console.log("Model versions verification failed");N.current=0;if(l){d(false)}b((e=>!e));return false}console.log("All model versions verified successfully!");O(true);return true}catch(e){console.error("Error verifying versions:",e);N.current=0;throw e}}}export default ModelService;